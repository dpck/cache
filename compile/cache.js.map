{
"version":3,
"file":"compile/cache.js",
"lineCount":398,
"mappings":"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",
"sources":["node_modules/crypto/index.js","node_modules/erotic/src/lib.js","node_modules/os/index.js","node_modules/@artdeco/clean-stack/src/index.js","node_modules/erotic/src/callback.js","node_modules/erotic/src/index.js","node_modules/makepromise/src/index.js","node_modules/fs/index.js","node_modules/@wrote/exists/src/index.js","node_modules/path/index.js","node_modules/resolve-dependency/src/index.js","node_modules/module/index.js","node_modules/stream/index.js","node_modules/catchment/src/lib/index.js","node_modules/catchment/src/index.js","node_modules/@wrote/read/src/index.js","node_modules/mismatch/src/index.js","node_modules/@depack/detect/src/index.js","node_modules/fpj/src/index.js","node_modules/static-analysis/src/lib.js","node_modules/@depack/split/src/index.js","node_modules/static-analysis/src/index.js","src/lib.js","node_modules/erte/src/index.js","src/depack.js","src/index.js"],
"sourcesContent":["export default _crypto\nexport const {\n  Certificate,\n  Cipher,\n  Credentials,\n  DEFAULT_ENCODING,\n  Decipher,\n  DiffieHellman,\n  ECDH,\n  Hash,\n  Hmac,\n  Verify,\n  createCipher,\n  createCipheriv,\n  createCredentials,\n  createDecipher,\n  createDecipheriv,\n  createDiffieHellman,\n  createECDH,\n  createHash,\n  createHmac,\n  createSign,\n  createVerify,\n  getCiphers,\n  getCurves,\n  getDiffieHellman,\n  getHashes,\n  pbkdf2,\n  pbkdf2Sync,\n  privateDecrypt,\n  privateEncrypt,\n  pseudoRandomBytes,\n  publicDecrypt,\n  publicEncrypt,\n  randomBytes,\n  randomFill,\n  randomFillSync,\n  timingSafeEqual,\n} = _crypto","const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : undefined)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {boolean} [transparent] trim the top line as well\n * @returns {string} A part of stack\n */\nexport const getEntryStack = (stack, transparent = false) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from the function's `arguments`.\n * @param {Object} args arguments\n * @returns {!Function} The caller function from `arguments.callee.caller`.\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}","export default os\nexport const {\n  EOL,\n  arch,\n  constants,\n  cpus,\n  endianness,\n  freemem,\n  homedir,\n  hostname,\n  loadavg,\n  networkInterfaces,\n  platform,\n  release,\n  tmpdir,\n  totalmem,\n  type,\n  uptime,\n  userInfo,\n} = os","import { homedir } from 'os'\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:IGNORED_MODULES)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/\n\nconst homeDir = homedir()\n\n/**\n * Remove internal Node.JS lines from the error stack traces.\n * @param {string} stack The error stack to update.\n * @param {!_cleanStack.Config} [options] Options for the program.\n * @param {boolean} [options.pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @param {!Array<string>} [options.ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\nconst cleanStack = (stack, options) => {\n  const {\n    pretty = false, ignoredModules = ['pirates'],\n  } = options || {}\n  const j = ignoredModules.join('|')\n  const re = new RegExp(pathRegex.source.replace('IGNORED_MODULES', j))\n\n  return stack.replace(/\\\\/g, '/')\n    .split('\\n')\n    .filter(x => {\n      const pathMatches = x.match(extractPathRegex)\n      if (pathMatches === null || !pathMatches[1]) {\n        return true\n      }\n\n      const match = pathMatches[1]\n\n      // Electron\n      if (match.includes('.app/Contents/Resources/electron.asar') ||\n        match.includes('.app/Contents/Resources/default_app.asar')) {\n        return false\n      }\n\n      return !re.test(match)\n    })\n    .filter(x => x.trim())\n    .map(x => {\n      if (pretty) {\n        return x.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')))\n      }\n\n      return x\n    })\n    .join('\\n')\n}\n\nexport default cleanStack\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_cleanStack.Config} Config Options for the program.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _cleanStack.Config Options for the program.\n * @prop {boolean} [pretty=false] Replace the absolute path to the home directory with the `~`. Default `false`.\n * @prop {!Array<string>} [ignoredModules=\"\uff3b'pirates'\uff3d\"] Which modules to ignore in the path. Default `\uff3b'pirates'\uff3d`.\n */\n","import cleanStack from '@artdeco/clean-stack'\nimport {\n  getCallerFromArguments, getCalleeStackLine, getStackHeading,\n} from './lib'\n\n/**\n * Create a callback.\n * @param {!Function} entryCaller The function which was called at entry.\n * @param {string} entryStack The first line of the error stack to be returned\n * @param {boolean} [shadow=false] Print only entry stack.\n */\nexport function makeCallback(entryCaller, entryStack, shadow = false) {\n  /**\n   * This callback should be called when an asynchronous error occurred.\n   * @param {(string|Error)} messageOrError A message string or an _Error_ object at the point of actual error.\n   * @returns {Error} An error with the updated stack which includes the callee.\n   */\n  function cb(messageOrError) {\n    const caller = getCallerFromArguments(arguments)\n    const { stack: errorStack } = new Error()\n    const calleeStackLine = getCalleeStackLine(errorStack)\n    const isError = messageOrError instanceof Error\n    const message = isError ? messageOrError.message : messageOrError\n\n    const stackHeading = getStackHeading(message)\n    const entryHasCallee = caller !== null && entryCaller === caller\n    const stackMessage = [\n      stackHeading,\n      ...(entryHasCallee || shadow ? [entryStack] : [\n        calleeStackLine,\n        entryStack,\n      ]),\n    ].join('\\n')\n\n    const stack = cleanStack(stackMessage)\n    const properties = { message, stack }\n    const e = isError ? messageOrError : new Error()\n\n    return /** @type {Error} */ (Object.assign(/** @type {!Object} */ (e), properties))\n  }\n\n  return cb\n}","import {\n  getEntryStack, getCallerFromArguments,\n} from './lib'\nimport { makeCallback } from './callback'\n\n/**\n * Returns a function to create an error with a stack trace starting at the line in code when the call was made by the callee.\n * @param {boolean} [transparent] Pretend as if the call to the function lead to the error, without exposing any of the internal stack.\n */\nexport default function erotic(transparent) {\n  const { stack } = new Error()\n  const caller = getCallerFromArguments(arguments)\n  const entryStack = getEntryStack(stack, transparent)\n\n  return makeCallback(caller, entryStack, transparent)\n}","import erotic from 'erotic'\n\n// /**\n//  * @param {number} length\n//  * @param {number} i\n//  * @param {!Function} fn\n//  */\n// function checkArgumentIndex(length, i, fn) {\n//   if (i > length - 2) {\n//     throw new Error(`Function${fn.name ? ` ${fn.name}` : ''} does not accept that many arguments (max ${length - 1} + callback).`)\n//   }\n// }\n\n/**\n * Get a promise from a function which otherwise accepts a callback.\n * @param {Function} fn A function to promisify.\n * @param {*|Array<*>} [args] An array of arguments to use in the call, or a single argument.\n * @param {*} [resolveValue] A value to override the value with which the promise will be resolved.\n * @returns {Promise<*>} A promise resolved on callback invocation without an error and rejected on callback called with an error.\n */\nexport default async function makePromise(fn, args, resolveValue) {\n  const er = erotic(true)\n  if (typeof fn != 'function') {\n    throw new Error('Function must be passed.')\n  }\n  const { length: fnLength } = fn\n  if (!fnLength) {\n    throw new Error(`Function${fn.name ? ` ${fn.name}` : ''} does not accept any arguments.`)\n  }\n\n  const res = await new Promise((resolve, reject)=> {\n    const cb = (err, res) => {\n      if (err) {\n        const error = er(err)\n        return reject(error)\n      }\n      return resolve(resolveValue || res)\n    }\n\n    let allArgs = [cb]\n\n    if (Array.isArray(args)) {\n      // args.forEach((arg, i) => {\n      //   checkArgumentIndex(fnLength, i, fn)\n      // })\n      allArgs =  [...args, cb]\n    } else if (Array.from(arguments).length > 1) { // args passed as a single argument, not array\n      // checkArgumentIndex(fnLength, 0, fn)\n      allArgs = [args, cb]\n    }\n    fn(...allArgs)\n  })\n  return res\n}","export default fs\nexport const {\n  ReadStream,\n  Stats,\n  WriteStream,\n  access,\n  accessSync,\n  appendFile,\n  appendFileSync,\n  chmod,\n  chmodSync,\n  chown,\n  chownSync,\n  close,\n  closeSync,\n  constants,\n  copyFile,\n  copyFileSync,\n  createReadStream,\n  createWriteStream,\n  exists,\n  existsSync,\n  fchmod,\n  fchmodSync,\n  fchown,\n  fchownSync,\n  fdatasync,\n  fdatasyncSync,\n  fstat,\n  fstatSync,\n  fsync,\n  fsyncSync,\n  ftruncate,\n  ftruncateSync,\n  futimes,\n  futimesSync,\n  lchmod,\n  lchmodSync,\n  lchown,\n  lchownSync,\n  link,\n  linkSync,\n  lstat,\n  lstatSync,\n  mkdir,\n  mkdirSync,\n  mkdtemp,\n  mkdtempSync,\n  open,\n  openSync,\n  read,\n  readFile,\n  readFileSync,\n  readSync,\n  readdir,\n  readdirSync,\n  readlink,\n  readlinkSync,\n  realpath,\n  realpathSync,\n  rename,\n  renameSync,\n  rmdir,\n  rmdirSync,\n  stat,\n  statSync,\n  symlink,\n  symlinkSync,\n  truncate,\n  truncateSync,\n  unlink,\n  unlinkSync,\n  unwatchFile,\n  utimes,\n  utimesSync,\n  watch,\n  watchFile,\n  write,\n  writeFile,\n  writeFileSync,\n  writeSync,\n} = fs","import makePromise from 'makepromise'\nimport { lstat } from 'fs'\n\n/**\n * Check If The File Or Directory Exists, And Return Stats.\n * @param {string} path The path to check for existence.\n */\nconst exists = async (path) => {\n  try {\n    const ls = /** @type {fs.Stats} */ (await makePromise(lstat, path))\n    return ls\n  } catch (err) {\n    return null\n  }\n}\n\nexport default exists\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */","export default path\nexport const {\n  basename,\n  delimiter,\n  dirname,\n  extname,\n  format,\n  isAbsolute,\n  join,\n  normalize,\n  parse,\n  posix,\n  relative,\n  resolve,\n  sep,\n  win32,\n} = path","import exists from '@wrote/exists'\nimport { dirname, join, relative } from 'path'\n\n/**\n * For the given local path that can omit the JS/JSX extension and point to a directory (e.g., `./lib` or `./lib/example`), find that file on the filesystem.\n * @param {string} path The dependency path, to resolve e.g., `./lib`.\n * @param {string} [relativeFrom] The optional path of the file that imports the given path.\n */\nconst resolveDependency = async (path, relativeFrom) => {\n  if (relativeFrom) {\n    const d = dirname(relativeFrom)\n    path = join(d, path)\n  }\n  let e = await exists(path)\n  let res = path\n  let isDir = false\n  if (!e) {\n    res = await checkSources(path)\n    if (!res) throw new Error(`${path}.js or ${path}.jsx is not found.`)\n  } else if (e.isDirectory()) {\n    // first try file\n    let fileChecked = false\n    let fileRes\n    if (!path.endsWith('/')) {\n      fileRes = res = await checkSources(path)\n      fileChecked = true\n    }\n    if (!fileRes) {\n      res = await checkSources(join(path, 'index'))\n      if (!res) {\n        const s = fileChecked ? `${path}.jsx? does not exist, and ` : ''\n        throw new Error(`${s}index.jsx? file is not found in ${path}`)\n      }\n      isDir = true\n    }\n  }\n  return {\n    path: path.startsWith('.') ? relative('', res) : res,\n    isDir,\n  }\n}\n\nconst checkSources = async (path) => {\n  let pp = `${path}.js`\n  let e = await exists(pp)\n  if (!e) pp = `${pp}x`; e = await exists(pp)\n  if (e) return pp\n}\n\nexport default resolveDependency","export default _module\nexport const {\n  Module,\n  builtinModules,\n  runMain,\n  wrap,\n} = _module","export default stream\nexport const {\n  Duplex,\n  PassThrough,\n  Readable,\n  Stream,\n  Transform,\n  Writable,\n} = stream","/**\n * Listens for the `error` event once so that when an error in _streamB_ is emitted, is is also emitted in the _streamA_.\n * @param {stream.Stream} streamA The stream that will emit an error once it's caught in the `streamB`.\n * @param {stream.Stream} streamB The stream from which the error originates.\n * @returns The stream the error is listened on, i.e., transparent to calling the `.once` method on that stream.\n */\nexport const pipeError = (streamA, streamB) => {\n  streamB\n    .once('error', e => {\n      streamA.emit('error', e)\n    })\n  return streamB\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Stream} stream.Stream\n */","import { Writable } from 'stream'\nimport erotic from 'erotic'\nimport cleanStack from '@artdeco/clean-stack'\nimport { pipeError } from './lib'\n\nfunction joinBufferData(array) {\n  return array.join('')\n}\n\n/**\n * A writable stream which collects incoming data into memory, and provides a promise to way for the stream to finish. The promise is resolved with joined chunks.\n */\nexport default class Catchment extends Writable {\n  /**\n   * Create a new catchment to pipe a readable stream into and collect all emitted data.\n   * @param {!_catchment.Options} [options] Options to pass to the `Writable` super constructor, and others shown below.\n   * @param {!stream.Readable} [options.rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n   * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n   * @example\n   *\n   * import { createReadStream } from 'fs'\n   * import Catchment from 'catchment'\n   *\n   * const rs = createReadStream('file.txt')\n   * const { promise } = new Catchment({ rs })\n   * const res = await promise\n   */\n  constructor(options) {\n    const {\n      binary = false, rs = null, ...opts\n    } = options || {}\n    /** @suppress {missingProperties} */\n    const { er = erotic(true), proxyError } = options || {}\n    const wrap = (_, e) => er(e)\n    super(/** @type {!stream.WritableOptions} */ (opts))\n    this._caughtData = []\n    this._promise = new Promise((r, j) => {\n      this.on('finish', () => {\n        let d\n        if (binary) {\n          d = Buffer.concat(this._caughtData)\n        } else {\n          d = joinBufferData(this._caughtData)\n        }\n        r(d)\n        this._caughtData = []\n      })\n      this.once('error', (e) => {\n        if (e.stack.indexOf('\\n') == -1) {\n          wrap`${e}`\n          j(e)\n        } else {\n          const stack = cleanStack(e.stack)\n          e.stack = stack\n          if (proxyError) wrap`${e}`\n          j(e)\n        }\n      })\n      if (rs) {\n        pipeError(this, rs).pipe(this)\n      }\n    })\n  }\n  _write(chunk, encoding, callback) {\n    this._caughtData.push(chunk)\n    callback()\n  }\n  /**\n   * A promise which will resolve will all data when the stream finishes.\n   * @type {Promise<string|Buffer>}\n   */\n  get promise() {\n    return this._promise\n  }\n}\n\n/**\n * Collect data into a catchment, and return results when the stream finishes.\n * @param {stream.Readable} readable A readable stream to collect all data from. If an error occurs during reading of this stream, the promise will be rejected with it.\n * @param {_catchment.CollectOptions} options Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @param {boolean} [options.binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @param {boolean} [options.proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n * @example\n *\n * import { collect } from 'catchment'\n * import { createReadStream } from 'fs'\n *\n * const rs = createReadStream(path)\n * await collect(rs, { proxyError: true })\n */\nexport const collect = async (readable, options = {}) => {\n  const { promise } = new Catchment({\n    rs: readable,\n    ...options,\n    er: erotic(true),\n  })\n  const res = await promise\n  return res\n}\n\n/* typal types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.Options} Options Options to pass to the `Writable` super constructor, and others shown below.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.Options Options to pass to the `Writable` super constructor, and others shown below.\n * @prop {!stream.Readable} [rs] A readable stream to automatically pipe into the catchment. If an error occurs during reading of this stream, the catchment promise will be rejected with it.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('stream').Readable} stream.Readable\n */\n\n/* typal types/collect.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_catchment.CollectOptions} CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {Object} _catchment.CollectOptions Options when collecting data into a catchment. They can extend `Writable` options which will be passed to the `Catchment` constructor.\n * @prop {boolean} [binary=false] Whether to return a raw buffer instead of a string. The string is created by joining all incoming chunks together with `.join('')` method. Default `false`.\n * @prop {boolean} [proxyError=false] Sets whether an error emitted by the stream with have its stack start at the line where the `collect` was called rather than inside of the stream. In other words, hides the implementation of the stream. Default `false`.\n */\n","import { createReadStream } from 'fs'\nimport { collect } from 'catchment'\n\n/**\n * Read a file.\n * @param {string} path The path to the file to read.\n */\nexport default async function read(path) {\n  const rs = createReadStream(path)\n  /** @type {string} */\n  const res = await collect(rs)\n  return res\n}\n\n/**\n * Read a file as a buffer.\n * @param {string} path The path to the file to read.\n */\nexport async function readBuffer(path) {\n  const rs = createReadStream(path)\n  /** @type {Buffer} */\n  const res = await collect(rs, { binary: true })\n  return res\n}","/**\n * Returns an array of captured groups of a regular expression as objects. Does not modify the `lastIndex` property of the regex.\n * @param {RegExp} re The regular expression used for matching.\n * @param {string} string String to find matches in.\n * @param {Array<string>} keys Keys to use to create an captured group object.\n * @param {boolean} addPositions Whether to include positions in the return.\n * @example\n *\n```js\nconst re = /(test) inside of a (string)(\\d)?/ig\nconst s = 'Test inside of a STRING1. TEST inside of a string.'\nconst keys = ['test', 'string', 'number']\nconst res = mismatch(re, s, keys)\n\n// result:\n[\n {\n   test: 'Test',\n   string: 'STRING',\n   number: '1',\n },\n {\n   test: 'TEST',\n   string: 'string',\n },\n]\n```\n */\nexport default function mismatch(re, string, keys, addPositions = false) {\n  /** @type {!Array<!Object<string, string>>} */\n  const m = []\n  string.replace(re, (match, ...args) => {\n    // remove position and input\n    const position = args[args.length - 2]\n    const start = addPositions ? { position } : {}\n    const p = args.slice(0, args.length - 2)\n    const o = p.reduce((acc, capturedGroup, i) => {\n      const key = keys[i]\n      if (!(key && capturedGroup !== undefined)) return acc\n      acc[key] = capturedGroup\n      return acc\n    }, start)\n    m.push(o)\n  })\n  return m\n}","import mismatch from 'mismatch'\n\nconst RE = /^ *import(?:\\s+(?:[^\\s,]+)\\s*,?)?(?:\\s*{(?:[^}]+)})?\\s+from\\s+(['\"])(.+?)\\1/gm\nconst RE2 = /^ *import\\s+(?:.+?\\s*,\\s*)?\\*\\s+as\\s+.+?\\s+from\\s+(['\"])(.+?)\\1/gm\nconst RE3 = /^ *import\\s+(['\"])(.+?)\\1/gm\nconst RE4 = /^ *export\\s+(?:{[^}]+?}|\\*)\\s+from\\s+(['\"])(.+?)\\1/gm\n\n/**\n * Returns the names of the modules imported with `import` and `export` statements.\n * @param {string} source The source to detect matches in.\n */\nconst getMatches = (source) => {\n  const res = [RE, RE2, RE3, RE4].reduce((acc, re) => {\n    const m = mismatch(re, source, ['q', 'from'])\n      .map(a => a['from'])\n    return [...acc, ...m]\n  }, [])\n  return res\n}\n\nexport default getMatches\n\nexport const RES = {\n  RE, RE2, RE3, RE4,\n}","import { join, relative, resolve, dirname, parse } from 'path'\r\nimport exists from '@wrote/exists'\r\nimport read from '@wrote/read'\r\nimport resolveDep from 'resolve-dependency'\r\n\r\nlet ROOT\r\n\r\n/**\r\n * Finds the location of the `package.json` for the given dependency in the directory, and its entry file.\r\n * @param {string} dir The path to the directory where the requiring file is located.\r\n * @param {string} name The name of the required package.\r\n * @param {!_fpj.Config} opts The options for `fpj`.\r\n * @param {!Array<string>} [opts.fields] Any additional fields from `package.json` file to return.\r\n * @param {boolean} [opts.soft=false] If the entry export (main or module) does not exist, `soft` mode will not throw an error, but add the `hasEntry` property to the output set to _false_. Default `false`.\r\n * @returns {!Promise<!_fpj.Return>}\r\n */\r\nconst findPackageJson = async (dir, name, opts = {}) => {\r\n  if (!ROOT) {\r\n    ({ root: ROOT } = parse(process.cwd()))\r\n  }\r\n  const { fields, soft = false } = opts\r\n  const fold = join(dir, 'node_modules', name)\r\n  const path = join(fold, 'package.json')\r\n  const e = await exists(path)\r\n  if (e) {\r\n    const res = await findEntry(path, fields)\r\n    if (res === undefined)\r\n      throw new Error(`The package ${relative('', path)} does export the module.`)\r\n    else if (!res.entryExists && !soft)\r\n      throw new Error(`The exported module ${res.main} in package ${name} does not exist.`)\r\n    const { entry, version, packageName, main, entryExists, ...rest } = res\r\n    const result = /** @type {!_fpj.Return} */ ({\r\n      entry: relative('', entry),\r\n      packageJson: relative('', path),\r\n      ...(version ? { version } : {}),\r\n      packageName,\r\n      ...(main ? { hasMain: true } : {}),\r\n      ...(!entryExists ? { entryExists: false } : {}),\r\n      ...rest,\r\n    })\r\n    return result\r\n  }\r\n  if (dir == ROOT && !e)\r\n    throw new Error(`Package.json for module ${name} not found.`)\r\n  return findPackageJson(join(resolve(dir), '..'), name, opts)\r\n}\r\n\r\n/**\r\n * Finds the path to the entry based on package.json file.\r\n * @param {string} path\r\n * @param {!Array<string>} fields\r\n */\r\nexport const findEntry = async (path, fields = []) => {\r\n  const f = await read(path)\r\n  let mod, version, packageName, main, rest\r\n  try {\r\n    ({\r\n      'module': mod,\r\n      'version': version,\r\n      'name': packageName,\r\n      'main': main,\r\n      ...rest\r\n    } = JSON.parse(f))\r\n    rest = fields.reduce((acc, current) => {\r\n      acc[current] = rest[current]\r\n      return acc\r\n    }, {})\r\n  } catch (err) {\r\n    throw new Error(`Could not parse ${path}.`)\r\n  }\r\n  const dir = dirname(path)\r\n  let resolved = mod || main\r\n  if (!resolved) {\r\n    const indexExists = await exists(join(dir, 'index.js'))\r\n    if (!indexExists) return undefined\r\n    resolved = main = 'index.js'\r\n  }\r\n  let entry = join(dir, resolved)\r\n  let r\r\n  try {\r\n    ({ path: r } = await resolveDep(entry))\r\n    entry = r\r\n  } catch (err) {/* does not exist */}\r\n  return { entry, version, packageName, main: !mod && main,\r\n    entryExists: !!r,\r\n    ...rest }\r\n}\r\n\r\nexport default findPackageJson\r\n\r\n/* documentary types/index.xml */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {_fpj.Config} Config The options for `fpj`.\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {Object} _fpj.Config The options for `fpj`.\r\n * @prop {!Array<string>} [fields] Any additional fields from `package.json` file to return.\r\n * @prop {boolean} [soft=false] If the entry export (main or module) does not exist, `soft` mode will not throw an error, but add the `hasEntry` property to the output set to _false_. Default `false`.\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {_fpj.Return} Return The return type of the program.\r\n */\r\n/**\r\n * @suppress {nonStandardJsDocs}\r\n * @typedef {Object} _fpj.Return The return type of the program.\r\n * @prop {string} entry The location of the package's entry file. The preference is given to the `module` field.\r\n * @prop {string} packageJson The path to the package.json file itself.\r\n * @prop {string} packageName The name of the resolved package.\r\n * @prop {string} [version] The version of the package.\r\n * @prop {boolean} [hasMain] Whether the entry is the `main` rather than `module`.\r\n * @prop {boolean} [entryExists] In soft mode, will be set to `false` if the entry file does not exist.\r\n */\r\n","import { dirname, join } from 'path'\nimport { builtinModules } from 'module'\nimport read from '@wrote/read'\nimport resolveDependency from 'resolve-dependency'\nimport getMatches from '@depack/detect'\nimport split from '@depack/split'\nimport findPackageJson from 'fpj'\nimport mismatch from 'mismatch'\nimport erotic from 'erotic'\n\nexport const checkIfLib = modName => /^[./]/.test(modName)\n\n/**\n * Expands the dependency match to include `package.json` and entry paths.\n * @param {string} path The path to the file.\n * @param {!Array<string>} matches The matches.\n * @param {boolean} [soft] Whether to throw when a dependency's package.json is not found.\n * @param {!Array<string>} [fields] What additional fields to fetch from package.json.\n * @returns {!Promise<!Array<!_staticAnalysis.DependencyMeta>>}\n */\nconst getDependenciesMeta = async (path, matches, soft, fields, pckg = null) => {\n  const e = erotic()\n  const dir = dirname(path)\n  const proms = matches.map(async (name) => {\n    const internal = builtinModules.includes(name)\n    if (internal) return { internal: name }\n    const isLib = checkIfLib(name)\n    if (isLib) {\n      try {\n        const { path: entry } = await resolveDependency(name, path)\n        return { entry, package: pckg }\n      } catch (err) { /*\n        maybe a local package with package.json\n      */}\n    } else {\n      const { name: n, paths } = split(name)\n      if (paths) {\n        const { packageJson, packageName } = await findPackageJson(dir, n)\n        const d = dirname(packageJson)\n        const { path: entry } = await resolveDependency(join(d, paths))\n        return { entry, package: packageName }\n      }\n    }\n    try {\n      const {\n        entry, packageJson, version, packageName, hasMain, ...rest\n      } = await findPackageJson(dir, name, { fields })\n      if (packageName == pckg) {\n        console.warn('[static-analysis] Skipping package %s that imports itself in %s', packageName, path)\n        return null\n      }\n      return {\n        entry, packageJson, version, name: packageName,\n        ...(hasMain ? { hasMain } : {}),\n        ...rest }\n    } catch (err) {\n      if (soft) return null\n      let [v] = process.version.split('.')\n      v = parseInt(v.replace('v', ''), 10)\n      if (v >= 12) throw err\n      throw e(err)\n    }\n  })\n  return (await Promise.all(proms)).filter(Boolean)\n}\n\n/**\n * Detects the imports.\n * @param {string} path\n * @param {Object} cache\n * @returns {!Promise<!Array<!_staticAnalysis.Detection>>}\n */\nexport const detect = async (path, cache = {}, {\n  nodeModules = true, shallow = false, soft = false, fields = [],\n  node_modules_cache = {},\n  mergeSameNodeModules = true,\n  package: pckg } = {}) => {\n  if (path in cache) return []\n  cache[path] = 1\n  const source = await read(path)\n  const matches = getMatches(source)\n  const requireMatches = getRequireMatches(source)\n  const fm = nodeModules ? matches : matches.filter(checkIfLib)\n  const fr = nodeModules ? requireMatches : requireMatches.filter(checkIfLib)\n\n  let deps\n  try {\n    const dm = await getDependenciesMeta(path, fm, soft, fields, pckg)\n    const rm = await getDependenciesMeta(path, fr, soft, fields, pckg)\n    rm.forEach((val) => {\n      val.required = true\n    })\n    deps = [...dm, ...rm]\n  } catch (err) {\n    err.message = `${path}\\n [!] ${err.message}`\n    throw err\n  }\n  const Deps = mergeSameNodeModules ? deps.map(o => {\n    const { name, version, required } = o\n    if (name && version) {\n      // for non-flattened node_modules structure, e.g., when linking\n      // to prevent multiple same packages like\n      // depA, node_modules/depB/node_modules/depA\n      const n = `${name}:${version}${required ? '-required' : ''}`\n      const existing = node_modules_cache[n]\n      if (existing) return existing\n\n      node_modules_cache[n] = o\n    }\n    return o\n  }) : deps\n  const d = Deps.map(o => ({ ...o, from: path }))\n  const entries = Deps\n    .filter(({ entry }) => {\n      return entry && !(entry in cache)\n    })\n  const discovered = await entries\n    .reduce(async (acc, {\n      entry, hasMain, packageJson, name, package: p }) => {\n      if (packageJson && shallow) return acc\n      const accRes = await acc\n      const res = await detect(entry, cache, {\n        nodeModules, shallow, soft, fields, package: name || p,\n        node_modules_cache, mergeSameNodeModules,\n      })\n      const r = res\n        .map(o => ({\n          ...o,\n          from: o.from ? o.from : entry,\n          ...(!o.packageJson && hasMain ? { hasMain } : {}),\n        }))\n      return [...accRes, ...r]\n    }, d)\n  return discovered\n}\n\nexport const getRequireMatches = (source) => {\n  const m = mismatch(/(?:^|[^\\w\\d_])require\\(\\s*(['\"])(.+?)\\1\\s*\\)/gm, source, ['q', 'from'])\n  const res = m.map(a => a['from'])\n  return res\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').Detection} _staticAnalysis.Detection\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('..').DependencyMeta} _staticAnalysis.DependencyMeta\n */","/**\n * Splits the package name possibly with scope and returns the name and the\n * path within that page that was required.\n * @param {string} from The package, e.g., `@depack/depack/src`, or `depack`.\n */\nconst split = (from) => {\n  let [scope, name, ...paths] = from.split('/')\n  if (!scope.startsWith('@') && name) {\n    paths = [name, ...paths]\n    name = scope\n  } else if (!scope.startsWith('@')) {\n    name = scope\n  } else {\n    name = `${scope}/${name}`\n  }\n  return { name, paths: paths.join('/') }\n}\n\nexport default split","import resolveDependency from 'resolve-dependency'\nimport erotic from 'erotic'\nimport { detect } from './lib'\n\n/**\n * Detects all dependencies in a file and their dependencies recursively.\n * @param {!Array<string>|string} path The path to the file in which to detect dependencies.\n * @param {!_staticAnalysis.Config} [config] The configuration options for `staticAnalysis`.\n * @return {!Promise<!Array<_staticAnalysis.Detection>>}\n */\nconst staticAnalysis = async (path, config = {}) => {\n  const e = erotic()\n  let paths = Array.isArray(path) ? path : [path]\n  paths = await Promise.all(paths.map(async p => {\n    const { path: pp } = await resolveDependency(p)\n    return pp\n  }))\n\n  const {\n    nodeModules = true,\n    shallow = false,\n    soft = false,\n    fields = [],\n    mergeSameNodeModules = true,\n  } = config\n  let detected\n  try {\n    const cache = {}\n\n    detected = await paths.reduce(async (acc, p) => {\n      acc = await acc\n      const res = await detect(p, cache, {\n        nodeModules, shallow, soft, fields, mergeSameNodeModules })\n      acc.push(...res)\n      return acc\n    }, [])\n  } catch (err) {\n    let [v] = process.version.split('.')\n    v = parseInt(v.replace('v', ''), 10)\n    if (v >= 12) throw err\n    throw e(err)\n  }\n  const filtered = detected.filter(({ internal, entry }, i) => {\n    if (internal) {\n      const fi = detected.findIndex(({ internal: ii }) => {\n        return ii == internal\n      })\n      return fi == i\n    }\n    const ei = detected.findIndex(({ entry: ee }) => {\n      return entry == ee\n    })\n    return ei == i\n  })\n  const f = filtered.map((ff) => {\n    const { entry, internal } = ff\n    const froms = detected\n      .filter(({ internal: i, entry: ee }) => {\n        if (internal) return internal == i\n        if (entry) return entry == ee\n      })\n      .map(({ from }) => from)\n      .filter((el, i, a) => a.indexOf(el) == i)\n    const newF =  { ...ff, from: froms }\n    return newF\n  })\n    .map(({ package: pckg, ...props }) => {\n      if (pckg) return { package: pckg, ...props }\n      return props\n    })\n  return f\n}\n\n/**\n * Sorts the detected dependencies into commonJS modules, packageJsons and internals.\n * @param {!Array<!_staticAnalysis.Detection>} detected The detected matches\n * @return {_staticAnalysis.SortReturn}\n */\nexport const sort = (detected) => {\n  const packageJsons = []\n  const commonJsPackageJsons = []\n  const commonJs = []\n  const js = []\n  const internals = []\n  const deps = []\n  detected\n    .forEach(({ packageJson, hasMain, name, entry, internal }) => {\n      if (internal) return internals.push(internal)\n\n      if (packageJson && hasMain)\n        commonJsPackageJsons.push(packageJson)\n      else if (packageJson) packageJsons.push(packageJson)\n      if (entry && hasMain) commonJs.push(entry)\n      else if (entry) js.push(entry)\n      if (name) deps.push(name)\n    })\n  return { commonJsPackageJsons,\n    packageJsons, commonJs, js, internals, deps }\n}\n\nexport default staticAnalysis\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../').Config} _staticAnalysis.Config\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../').SortReturn} _staticAnalysis.SortReturn\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../').Detection} _staticAnalysis.Detection\n */","import staticAnalysis from 'static-analysis'\nimport resolveDependency from 'resolve-dependency'\nimport { c } from 'erte'\nimport { lstat } from 'fs'\nimport makePromise from 'makepromise'\n\nexport const compareHash = (currentHash, hash, log = console.log) => {\n  const added = []\n  const removed = []\n  hash.forEach((mm) => {\n    if (!currentHash.includes(mm)) {\n      added.push(mm)\n    }\n  })\n  currentHash.forEach((mm) => {\n    if (!hash.includes(mm)) {\n      removed.push(mm)\n    }\n  })\n  const changed = added.length || removed.length\n\n  if (!changed) return true\n  added.forEach((mm) => {\n    const { entry, mmeta } = getMetaToPrint(mm)\n    log(c('+', 'green'), entry, mmeta)\n  })\n  removed.forEach((mm) => {\n    const { entry, mmeta } = getMetaToPrint(mm)\n    log(c('-', 'red'), entry, mmeta)\n  })\n  return false\n}\n\nconst getMetaToPrint = (mm) => {\n  const [entry, meta] = mm.split(' ')\n  let mmeta = ''\n  if (meta) {\n    mmeta = /^\\d+$/.test(meta) ? new Date(parseInt(meta, 10)).toLocaleString() : meta\n  }\n  return { entry, mmeta }\n}\n\nexport const getMtime = async (entry) => {\n  const stat = /** @type {!fs.Stats} */ (await makePromise(lstat, entry))\n  const mtime = stat.mtime\n  return mtime.getTime()\n}\n\nexport const computeHash = async (analysis) => {\n  const hash = await Promise.all(analysis.map(async ({ entry, name, internal, version }) => {\n    if (name) return `${name} ${version}`\n    if (internal) return internal\n    const mtime = await getMtime(entry)\n    return `${entry} ${mtime}`\n  }))\n  return hash\n}\n\n\nexport const analyse = async (mod) => {\n  const analysis = await staticAnalysis(mod, {\n    shallow: true,\n    soft: true,\n  })\n  const hash = await computeHash(analysis)\n\n  const { path: mmod } = await resolveDependency(mod)\n  const mmtime = await getMtime(mmod)\n\n  return { mtime: mmtime, hash, analysis }\n}\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('fs').Stats} fs.Stats\n */","import Diff from './diff'\n\nconst colors = {\n  'black': 30,\n  'red': 31,\n  'green': 32,\n  'yellow': 33,\n  'blue': 34,\n  'magenta': 35,\n  'cyan': 36,\n  'white': 37,\n  'grey': 90,\n}\n\nconst backgroundColors = {\n  'black': 40,\n  'red': 41,\n  'green': 42,\n  'yellow': 43,\n  'blue': 44,\n  'magenta': 45,\n  'cyan': 46,\n  'white': 47,\n}\n\n/**\n * Color the foreground.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function c(string, color) {\n  const cc = colors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Color the background.\n * @param {string} string The string to color.\n * @param {_erte.Color} color The color to apply.\n */\nexport function b(string, color) {\n  const cc = backgroundColors[color]\n  if (!cc) return string\n  return `\\x1b[${cc}m${string}\\x1b[0m`\n}\n\n/**\n * Compares two strings and outputs a coloured version where strings don't match.\n * @param {string} source A string to compare.\n * @param {string} target Target string to compare with.\n * @returns {string} A string which uses shell-codes to highligh differences.\n */\nexport default function erte(source, target) {\n  const diff = new Diff()\n  const d = diff.diff(source, target)\n  const m = d.map(({ added, removed, value }) => {\n    let p\n    const s = value.split(' ')\n    if (added) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'green')).join(b(' ', 'green'))\n    } else if (removed) {\n      p = s.map(t => {\n        return t.replace(/\\n$/mg, '\u23ce\\n')\n      }).map(t => c(t, 'red')).join(b(' ', 'red'))\n    } else {\n      p = c(value, 'grey')\n    }\n    return p\n  })\n  const s = m.join('')\n  return s\n}\n\n/* documentary types/index.xml */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {_erte.Color} Color The color to apply.\n */\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {('black'|'red'|'green'|'yellow'|'blue'|'magenta'|'cyan'|'white'|'grey')} _erte.Color The color to apply.\n */\n","import '../types/externs'\nimport cache from './'\n\nmodule.exports = cache","import { createHash } from 'crypto'\nimport { compareHash, analyse } from './lib'\n\n/** @type {_depack.compare} */\nconst compare = async (mod, cache = {}, log = console.log) => {\n  const current = cache[mod]\n  const { mtime, hash } = await analyse(mod)\n\n  const md5 = /** @type {string} */ (createHash('md5').update(JSON.stringify(hash)).digest(\"hex\"))\n\n  if (!current) return {\n    result: false, reason: 'NO_CACHE', mtime, hash, md5,\n  }\n\n  const {\n    'mtime': currentMtime,\n    'hash': currentHash,\n  } = current\n\n  if (mtime != currentMtime) return {\n    result: false, reason: 'MTIME_CHANGE', mtime, hash, currentMtime, md5,\n  }\n  const isHashSame = compareHash(currentHash, hash, log)\n  if (isHashSame ) return { result: true, md5 }\n\n\n  return { result: false, mtime, hash, reason: 'HASH_CHANGE', md5 }\n}\n\nexport default compare\n\n/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../types').compare} _depack.compare\n */"],
"names":["createHash","_crypto","getStackSegment","stack","from","oneLine","splitStack","split","undefined","item","length","slice","items","join","getEntryStack","transparent","stackSegment","getCallerFromArguments","args","caller","homedir","os","extractPathRegex","pathRegex","homeDir","cleanStack","pretty","ignoredModules","j","re","RegExp","source","replace","filter","x","pathMatches","match","includes","test","trim","map","m","p1","makeCallback","entryCaller","entryStack","shadow","cb","messageOrError","arguments","errorStack","Error","calleeStackLine","message","isError","stackMessage","stackHeading","Object","assign","e","properties","erotic","makePromise","fn","resolveValue","er","fnLength","name","res","Promise","resolve","reject","err","error","allArgs","Array","isArray","createReadStream","fs","lstat","exists","path","ls","dirname","parse","relative","resolveDependency","relativeFrom","d","isDir","checkSources","isDirectory","fileChecked","fileRes","endsWith","s","startsWith","pp","builtinModules","_module","Writable","stream","pipeError","streamA","streamB","once","emit","Catchment","options","binary","rs","opts","proxyError","wrap","_","_caughtData","_promise","r","on","Buffer","concat","indexOf","pipe","chunk","encoding","callback","push","collect","readable","promise","read","mismatch","string","keys","o","p","reduce","acc","capturedGroup","i","key","start","RE","RE2","RE3","RE4","getMatches","a","ROOT","findPackageJson","dir","process","cwd","fields","soft","fold","findEntry","entryExists","main","entry","version","packageName","rest","result","packageJson","hasMain","f","mod","JSON","current","resolved","indexExists","checkIfLib","modName","getDependenciesMeta","matches","pckg","proms","internal","isLib","package","scope","paths","n","console","warn","v","parseInt","all","Boolean","detect","cache","nodeModules","shallow","node_modules_cache","mergeSameNodeModules","requireMatches","getRequireMatches","fm","fr","dm","rm","forEach","val","required","deps","Deps","existing","discovered","entries","accRes","staticAnalysis","config","detected","filtered","findIndex","fi","ii","ei","ee","ff","froms","el","newF","props","colors","c","color","cc","compareHash","currentHash","hash","log","added","removed","mm","mmeta","getMetaToPrint","meta","toLocaleString","Date","getMtime","mtime","stat","getTime","computeHash","analysis","analyse","mmod","mmtime","module","exports","compare","md5","update","stringify","digest","reason","currentMtime","isHashSame"]
}
